"use strict";(globalThis.webpackChunkhumanoid_robotics_docs=globalThis.webpackChunkhumanoid_robotics_docs||[]).push([[109],{4074:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"foundations/index","title":"Robotics Foundations","description":"Core concepts and mathematical foundations for humanoid robotics","source":"@site/docs/foundations/index.md","sourceDirName":"foundations","slug":"/docs/foundations","permalink":"/docs/docs/foundations","draft":false,"unlisted":false,"editUrl":"https://github.com/Rizwanyaqoob/Humanoid-Robotics-A-Practical-Introduction/tree/master/docs/foundations/index.md","tags":[],"version":"current","frontMatter":{"title":"Robotics Foundations","description":"Core concepts and mathematical foundations for humanoid robotics","slug":"/docs/foundations"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Humanoid Robotics","permalink":"/docs/docs/intro"},"next":{"title":"Robotics Foundations","permalink":"/docs/docs/foundations"}}');var o=i(4848),s=i(8453);const a={title:"Robotics Foundations",description:"Core concepts and mathematical foundations for humanoid robotics",slug:"/docs/foundations"},r="Robotics Foundations",l={},c=[{value:"Motivation",id:"motivation",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Kinematics and Dynamics",id:"kinematics-and-dynamics",level:3},{value:"Control Theory",id:"control-theory",level:3},{value:"Sensor Fusion",id:"sensor-fusion",level:3},{value:"Mathematical Foundations",id:"mathematical-foundations",level:3},{value:"Linear Algebra in Robotics",id:"linear-algebra-in-robotics",level:4},{value:"Kinematics",id:"kinematics",level:4},{value:"Practical Examples",id:"practical-examples",level:2},{value:"PID Control Implementation",id:"pid-control-implementation",level:3},{value:"Sensor Fusion with Kalman Filter",id:"sensor-fusion-with-kalman-filter",level:3},{value:"Code Blocks",id:"code-blocks",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Quiz",id:"quiz",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"robotics-foundations",children:"Robotics Foundations"})}),"\n",(0,o.jsx)(e.h2,{id:"motivation",children:"Motivation"}),"\n",(0,o.jsx)(e.p,{children:"Understanding the foundational concepts of robotics is essential for developing humanoid robots. This section covers the mathematical, control, and sensor foundations that enable sophisticated humanoid behavior. These concepts form the backbone of all advanced robotics applications."}),"\n",(0,o.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,o.jsx)(e.h3,{id:"kinematics-and-dynamics",children:"Kinematics and Dynamics"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Kinematics: Motion description without considering forces"}),"\n",(0,o.jsx)(e.li,{children:"Dynamics: Motion description with forces and torques"}),"\n",(0,o.jsx)(e.li,{children:"Forward and inverse kinematics for controlling robot limbs"}),"\n",(0,o.jsx)(e.li,{children:"Jacobian matrices for relating joint velocities to end-effector velocities"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"control-theory",children:"Control Theory"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Feedback control systems"}),"\n",(0,o.jsx)(e.li,{children:"Stability analysis"}),"\n",(0,o.jsx)(e.li,{children:"Trajectory planning"}),"\n",(0,o.jsx)(e.li,{children:"Adaptive control for changing environments"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"sensor-fusion",children:"Sensor Fusion"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Combining data from multiple sensors"}),"\n",(0,o.jsx)(e.li,{children:"Kalman filtering and particle filters"}),"\n",(0,o.jsx)(e.li,{children:"State estimation"}),"\n",(0,o.jsx)(e.li,{children:"Handling sensor noise and uncertainty"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"mathematical-foundations",children:"Mathematical Foundations"}),"\n",(0,o.jsx)(e.h4,{id:"linear-algebra-in-robotics",children:"Linear Algebra in Robotics"}),"\n",(0,o.jsx)(e.p,{children:"Linear algebra is essential for representing positions, orientations, and transformations in 3D space:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\n# Homogeneous transformation matrix\ndef create_transform(translation, rotation_matrix):\n    """Create a 4x4 homogeneous transformation matrix"""\n    transform = np.eye(4)\n    transform[0:3, 0:3] = rotation_matrix\n    transform[0:3, 3] = translation\n    return transform\n\n# Example: Translation of (1, 2, 3) with no rotation\nT = create_transform([1, 2, 3], np.eye(3))\nprint(T)\n'})}),"\n",(0,o.jsx)(e.h4,{id:"kinematics",children:"Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Kinematics describes the motion of systems without considering the forces that cause the motion:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Forward kinematics example for a simple 2-DOF arm\ndef forward_kinematics(theta1, theta2, l1, l2):\n    """Calculate end-effector position given joint angles"""\n    x = l1 * np.cos(theta1) + l2 * np.cos(theta1 + theta2)\n    y = l1 * np.sin(theta1) + l2 * np.sin(theta1 + theta2)\n    return x, y\n\n# Inverse kinematics example\ndef inverse_kinematics(x, y, l1, l2):\n    """Calculate joint angles given end-effector position"""\n    # Calculate distance from origin to target\n    r = np.sqrt(x**2 + y**2)\n\n    # Check if target is reachable\n    if r > l1 + l2:\n        raise ValueError("Target is out of reach")\n\n    # Calculate joint angles\n    cos_theta2 = (r**2 - l1**2 - l2**2) / (2 * l1 * l2)\n    theta2 = np.arccos(np.clip(cos_theta2, -1, 1))\n\n    k1 = l1 + l2 * np.cos(theta2)\n    k2 = l2 * np.sin(theta2)\n\n    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n    return theta1, theta2\n'})}),"\n",(0,o.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,o.jsx)(e.h3,{id:"pid-control-implementation",children:"PID Control Implementation"}),"\n",(0,o.jsx)(e.p,{children:"Proportional-Integral-Derivative (PID) control is fundamental for robot control systems:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class PIDController:\n    def __init__(self, kp, ki, kd, dt=0.01):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.dt = dt\n\n        self.prev_error = 0\n        self.integral = 0\n\n    def update(self, setpoint, measured_value):\n        error = setpoint - measured_value\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * self.dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        derivative = (error - self.prev_error) / self.dt\n        d_term = self.kd * derivative\n\n        # Store current error for next iteration\n        self.prev_error = error\n\n        # Calculate output\n        output = p_term + i_term + d_term\n        return output\n"})}),"\n",(0,o.jsx)(e.h3,{id:"sensor-fusion-with-kalman-filter",children:"Sensor Fusion with Kalman Filter"}),"\n",(0,o.jsx)(e.p,{children:"Sensor fusion combines data from multiple sensors to improve accuracy and reliability:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import numpy as np\n\nclass KalmanFilter:\n    def __init__(self, process_noise, measurement_noise, initial_state, initial_uncertainty):\n        self.F = np.eye(len(initial_state))  # State transition model\n        self.H = np.eye(len(initial_state))  # Observation model\n        self.Q = np.eye(len(initial_state)) * process_noise  # Process noise\n        self.R = np.eye(len(initial_state)) * measurement_noise  # Measurement noise\n        self.P = np.eye(len(initial_state)) * initial_uncertainty  # Error covariance\n        self.x = np.array(initial_state)  # State estimate\n\n    def predict(self):\n        # Predict step\n        self.x = np.dot(self.F, self.x)\n        self.P = np.dot(np.dot(self.F, self.P), self.F.T) + self.Q\n\n    def update(self, measurement):\n        # Update step\n        y = measurement - np.dot(self.H, self.x)  # Innovation\n        S = np.dot(np.dot(self.H, self.P), self.H.T) + self.R  # Innovation covariance\n        K = np.dot(np.dot(self.P, self.H.T), np.linalg.inv(S))  # Kalman gain\n\n        self.x = self.x + np.dot(K, y)\n        self.P = np.dot((np.eye(len(self.P)) - np.dot(K, self.H)), self.P)\n"})}),"\n",(0,o.jsx)(e.h2,{id:"code-blocks",children:"Code Blocks"}),"\n",(0,o.jsx)(e.p,{children:"The control loop for a humanoid robot involves perception, planning, and action:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[Perception] --\x3e B[Situation Assessment]\n    B --\x3e C[Goal Formation]\n    C --\x3e D[Action Planning]\n    D --\x3e E[Motor Control]\n    E --\x3e F[Actuation]\n    F --\x3e G[Environment]\n    G --\x3e A\n    D -.-> H[Simulation]\n    H -.-> D\n"})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,o.jsx)(e.p,{children:"Common issues in foundational robotics:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Numerical instability in kinematic calculations"}),"\n",(0,o.jsx)(e.li,{children:"Joint limits causing singularities"}),"\n",(0,o.jsx)(e.li,{children:"Integration errors in control systems"}),"\n",(0,o.jsx)(e.li,{children:"Sensor noise affecting state estimation"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"quiz",children:"Quiz"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"What are the three components of a PID controller?"}),"\n",(0,o.jsx)(e.li,{children:"What is the difference between forward and inverse kinematics?"}),"\n",(0,o.jsx)(e.li,{children:"Why is sensor fusion important in robotics?"}),"\n",(0,o.jsx)(e.li,{children:"How does embodied intelligence differ from traditional AI approaches?"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(e.p,{children:["Continue to the ",(0,o.jsx)(e.a,{href:"../ros2/",children:"ROS 2"})," section to learn about the Robot Operating System, which provides the communication framework for humanoid robotics applications."]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>r});var t=i(6540);const o={},s=t.createContext(o);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);