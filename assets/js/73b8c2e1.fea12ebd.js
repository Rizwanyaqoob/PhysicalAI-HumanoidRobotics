"use strict";(globalThis.webpackChunkhumanoid_robotics_docs=globalThis.webpackChunkhumanoid_robotics_docs||[]).push([[870],{7259:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"motion-planning/index","title":"Motion Planning","description":"Path planning, trajectory optimization, and locomotion for humanoid robots","source":"@site/docs/motion-planning/index.md","sourceDirName":"motion-planning","slug":"/docs/motion-planning","permalink":"/PhysicalAI-HumanoidRobotics/docs/docs/motion-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Rizwanyaqoob/Humanoid-Robotics-A-Practical-Introduction/tree/master/docs/motion-planning/index.md","tags":[],"version":"current","frontMatter":{"title":"Motion Planning","description":"Path planning, trajectory optimization, and locomotion for humanoid robots","slug":"/docs/motion-planning"},"sidebar":"tutorialSidebar","previous":{"title":"Perception Systems","permalink":"/PhysicalAI-HumanoidRobotics/docs/docs/perception"},"next":{"title":"Motion Planning","permalink":"/PhysicalAI-HumanoidRobotics/docs/docs/motion-planning"}}');var t=o(4848),r=o(8453);const a={title:"Motion Planning",description:"Path planning, trajectory optimization, and locomotion for humanoid robots",slug:"/docs/motion-planning"},l="Motion Planning",s={},c=[{value:"Motivation",id:"motivation",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:3},{value:"Trajectory Optimization",id:"trajectory-optimization",level:3},{value:"Humanoid Locomotion",id:"humanoid-locomotion",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"A* Path Planning Implementation",id:"a-path-planning-implementation",level:3},{value:"Trajectory Generation for Humanoid",id:"trajectory-generation-for-humanoid",level:3},{value:"Code Blocks",id:"code-blocks",level:2},{value:"Humanoid Motion Planning Architecture",id:"humanoid-motion-planning-architecture",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Quiz",id:"quiz",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"motion-planning",children:"Motion Planning"})}),"\n",(0,t.jsx)(e.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsx)(e.p,{children:"Motion planning is the process of determining a valid path for a robot to move from a start configuration to a goal configuration while avoiding obstacles. For humanoid robots, this becomes particularly complex due to their high degrees of freedom and the need for dynamic balance during movement."}),"\n",(0,t.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(e.h3,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"A* and Dijkstra's algorithm for optimal pathfinding"}),"\n",(0,t.jsx)(e.li,{children:"RRT (Rapidly-exploring Random Trees) for high-dimensional spaces"}),"\n",(0,t.jsx)(e.li,{children:"PRM (Probabilistic Roadmap) for complex environments"}),"\n",(0,t.jsx)(e.li,{children:"Sampling-based vs. optimization-based approaches"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"trajectory-optimization",children:"Trajectory Optimization"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Smooth trajectory generation"}),"\n",(0,t.jsx)(e.li,{children:"Dynamic constraints for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Time-optimal vs. energy-optimal trajectories"}),"\n",(0,t.jsx)(e.li,{children:"Real-time replanning capabilities"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-locomotion",children:"Humanoid Locomotion"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Walking pattern generation"}),"\n",(0,t.jsx)(e.li,{children:"Balance control during movement"}),"\n",(0,t.jsx)(e.li,{children:"Footstep planning for complex terrain"}),"\n",(0,t.jsx)(e.li,{children:"Gait adaptation to different surfaces"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,t.jsx)(e.h3,{id:"a-path-planning-implementation",children:"A* Path Planning Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import heapq\nimport numpy as np\n\ndef a_star(grid, start, goal):\n    """A* path planning algorithm for grid-based environments"""\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n\n        if current == goal:\n            return reconstruct_path(came_from, current)\n\n        for neighbor in get_neighbors(current, grid):\n            tentative_g_score = g_score[current] + distance(current, neighbor)\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None  # No path found\n\ndef heuristic(a, b):\n    """Heuristic function for A* (Euclidean distance)"""\n    return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"trajectory-generation-for-humanoid",children:"Trajectory Generation for Humanoid"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom scipy import interpolate\n\nclass TrajectoryGenerator:\n    def __init__(self, dt=0.01):\n        self.dt = dt\n\n    def generate_swing_foot_trajectory(self, start_pos, goal_pos, height=0.1):\n        \"\"\"Generate a smooth trajectory for swinging foot during walking\"\"\"\n        # Define intermediate points for foot trajectory\n        mid_point = (start_pos + goal_pos) / 2\n        mid_point[2] += height  # Lift foot at midpoint\n\n        # Create time vector\n        duration = np.linalg.norm(goal_pos - start_pos) / 0.5  # Assume 0.5 m/s\n        t = np.arange(0, duration, self.dt)\n\n        # Generate trajectory using polynomial interpolation\n        control_points = np.array([start_pos, mid_point, goal_pos])\n        t_control = np.array([0, duration/2, duration])\n\n        # Interpolate each dimension separately\n        x_interp = interpolate.interp1d(t_control, control_points[:, 0], kind='cubic')\n        y_interp = interpolate.interp1d(t_control, control_points[:, 1], kind='cubic')\n        z_interp = interpolate.interp1d(t_control, control_points[:, 2], kind='cubic')\n\n        trajectory = np.column_stack([\n            x_interp(t),\n            y_interp(t),\n            z_interp(t)\n        ])\n\n        return trajectory, t\n"})}),"\n",(0,t.jsx)(e.h2,{id:"code-blocks",children:"Code Blocks"}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-motion-planning-architecture",children:"Humanoid Motion Planning Architecture"}),"\n",(0,t.jsx)(e.mermaid,{value:"graph TD\n    A[High-level Goal] --\x3e B[Global Path Planner]\n    B --\x3e C[Local Trajectory Planner]\n    C --\x3e D[Balance Controller]\n    D --\x3e E[Joint Trajectory Generator]\n    E --\x3e F[Robot Actuators]\n    F --\x3e G[Environment]\n    G --\x3e A\n    C -.-> H[Obstacle Detection]\n    H -.-> C"}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsx)(e.p,{children:"Common issues in motion planning:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Local minima in potential field methods"}),"\n",(0,t.jsx)(e.li,{children:"High computational complexity in high-DOF systems"}),"\n",(0,t.jsx)(e.li,{children:"Dynamic obstacle avoidance in real-time"}),"\n",(0,t.jsx)(e.li,{children:"Balance maintenance during complex movements"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"quiz",children:"Quiz"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"What is the main advantage of RRT over A* in high-dimensional spaces?"}),"\n",(0,t.jsx)(e.li,{children:"How does trajectory optimization differ from path planning?"}),"\n",(0,t.jsx)(e.li,{children:"What are the key challenges in humanoid locomotion planning?"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(e.p,{children:["Continue to ",(0,t.jsx)(e.a,{href:"../reinforcement-learning/",children:"Reinforcement Learning"})," to learn about AI techniques for improving robot behavior through learning."]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>a,x:()=>l});var i=o(6540);const t={},r=i.createContext(t);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);