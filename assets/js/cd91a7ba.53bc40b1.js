"use strict";(globalThis.webpackChunkhumanoid_robotics_docs=globalThis.webpackChunkhumanoid_robotics_docs||[]).push([[99],{120:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"digital-twin/index","title":"Digital Twins for Humanoid Robotics","description":"Simulation environments for testing and validating humanoid robots using Gazebo, Unity, and Isaac Sim","source":"@site/docs/digital-twin/index.md","sourceDirName":"digital-twin","slug":"/docs/digital-twin","permalink":"/PhysicalAI-HumanoidRobotics/docs/docs/digital-twin","draft":false,"unlisted":false,"editUrl":"https://github.com/Rizwanyaqoob/Humanoid-Robotics-A-Practical-Introduction/tree/master/docs/digital-twin/index.md","tags":[],"version":"current","frontMatter":{"title":"Digital Twins for Humanoid Robotics","description":"Simulation environments for testing and validating humanoid robots using Gazebo, Unity, and Isaac Sim","slug":"/docs/digital-twin"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 - The Robotic Nervous System","permalink":"/PhysicalAI-HumanoidRobotics/docs/docs/ros2"},"next":{"title":"Digital Twins for Humanoid Robotics","permalink":"/PhysicalAI-HumanoidRobotics/docs/docs/digital-twin"}}');var t=i(4848),s=i(8453);const a={title:"Digital Twins for Humanoid Robotics",description:"Simulation environments for testing and validating humanoid robots using Gazebo, Unity, and Isaac Sim",slug:"/docs/digital-twin"},l="Digital Twins for Humanoid Robotics",r={},c=[{value:"Motivation",id:"motivation",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Simulation Environments",id:"simulation-environments",level:3},{value:"Key Components",id:"key-components",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"URDF Model for Humanoid Robot",id:"urdf-model-for-humanoid-robot",level:3},{value:"Gazebo World Configuration",id:"gazebo-world-configuration",level:3},{value:"Code Blocks",id:"code-blocks",level:2},{value:"ROS-Gazebo Integration Example",id:"ros-gazebo-integration-example",level:3},{value:"Simulation Architecture Visualization",id:"simulation-architecture-visualization",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Quiz",id:"quiz",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"digital-twins-for-humanoid-robotics",children:"Digital Twins for Humanoid Robotics"})}),"\n",(0,t.jsx)(e.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsx)(e.p,{children:"A digital twin is a virtual representation of a physical system that simulates its behavior in real-time. In humanoid robotics, digital twins are crucial for testing and validating robot behaviors before deployment on expensive hardware. They allow developers to iterate quickly, test dangerous scenarios safely, and validate control algorithms in a controlled environment."}),"\n",(0,t.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(e.h3,{id:"simulation-environments",children:"Simulation Environments"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo"}),": Physics-based simulation with realistic dynamics and sensor simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unity"}),": High-fidelity rendering and human-robot interaction scenes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Isaac Sim"}),": NVIDIA's simulation platform with synthetic data generation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Webots"}),": General-purpose robot simulation software"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"key-components",children:"Key Components"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"}),": Describes robot kinematics and dynamics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"SDF (Simulation Description Format)"}),": Describes simulation worlds and objects"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics Engines"}),": Handle collision detection and dynamic simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Simulation"}),": Simulates LiDAR, cameras, IMUs, and other sensors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS Integration"}),": Bridges simulation and real robot control systems"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,t.jsx)(e.h3,{id:"urdf-model-for-humanoid-robot",children:"URDF Model for Humanoid Robot"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="1" ixy="0" ixz="0" iyy="1" iyz="0" izz="1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head link --\x3e\n  <link name="head">\n    <visual>\n      <geometry>\n        <sphere radius="0.05"/>\n      </geometry>\n      <material name="white">\n        <color rgba="1 1 1 1"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Joint connecting base to head --\x3e\n  <joint name="head_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.15"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n  </joint>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"gazebo-world-configuration",children:"Gazebo World Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.6">\n  <world name="simple_world">\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.6 0.4 -0.8</direction>\n    </light>\n\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.3 0.3 0.3 1</ambient>\n            <diffuse>0.5 0.5 0.5 1</diffuse>\n            <specular>0.8 0.8 0.8 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"code-blocks",children:"Code Blocks"}),"\n",(0,t.jsx)(e.h3,{id:"ros-gazebo-integration-example",children:"ROS-Gazebo Integration Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nimport math\n\nclass GazeboRobotController(Node):\n    def __init__(self):\n        super().__init__('gazebo_robot_controller')\n\n        # Publisher for robot velocity commands\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n\n        # Subscriber for laser scan data\n        self.scan_sub = self.create_subscription(\n            LaserScan, '/scan', self.scan_callback, 10)\n\n        # Timer for control loop\n        self.timer = self.create_timer(0.1, self.control_loop)\n\n        self.scan_data = None\n        self.obstacle_detected = False\n\n    def scan_callback(self, msg):\n        self.scan_data = msg\n        # Check for obstacles in front of the robot\n        if self.scan_data:\n            front_scan = self.scan_data.ranges[0]  # Front reading\n            if front_scan < 1.0:  # Obstacle within 1 meter\n                self.obstacle_detected = True\n            else:\n                self.obstacle_detected = False\n\n    def control_loop(self):\n        cmd = Twist()\n\n        if self.obstacle_detected:\n            # Stop and rotate to avoid obstacle\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.5\n        else:\n            # Move forward\n            cmd.linear.x = 0.5\n            cmd.angular.z = 0.0\n\n        self.cmd_vel_pub.publish(cmd)\n\ndef main():\n    rclpy.init()\n    controller = GazeboRobotController()\n    rclpy.spin(controller)\n    controller.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"simulation-architecture-visualization",children:"Simulation Architecture Visualization"}),"\n",(0,t.jsx)(e.mermaid,{value:"graph TB\n    A[Physical Robot] <--\x3e B[Digital Twin]\n    B --\x3e C[Gazebo Simulation]\n    B --\x3e D[Unity Environment]\n    B --\x3e E[Isaac Sim]\n    C --\x3e F[Physics Engine]\n    C --\x3e G[Sensor Simulation]\n    D --\x3e H[High-Fidelity Rendering]\n    E --\x3e I[Synthetic Data Generation]\n    F --\x3e J[Collision Detection]\n    G --\x3e K[LiDAR/Camera/IMU Simulation]\n    J --\x3e A\n    K --\x3e A"}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsx)(e.p,{children:"Common issues in digital twin development:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics accuracy"}),": Simulation may not match real-world dynamics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor fidelity"}),": Simulated sensors may not perfectly match real sensors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Timing differences"}),": Simulation time vs real-time execution"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Model complexity"}),": Complex models may cause performance issues"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integration problems"}),": Communication issues between ROS and simulation"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"quiz",children:"Quiz"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"What is the purpose of a digital twin in humanoid robotics?"}),"\n",(0,t.jsx)(e.li,{children:"What are the key differences between Gazebo, Unity, and Isaac Sim?"}),"\n",(0,t.jsx)(e.li,{children:"Why is URDF important for robot simulation?"}),"\n",(0,t.jsx)(e.li,{children:"What are the advantages of testing in simulation before real-world deployment?"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(e.p,{children:["Continue to the ",(0,t.jsx)(e.a,{href:"../isaac/",children:"NVIDIA Isaac"})," section to learn about Isaac Sim and perception modules for humanoid robots."]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var o=i(6540);const t={},s=o.createContext(t);function a(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);